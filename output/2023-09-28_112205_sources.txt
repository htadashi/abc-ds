


[BEGIN] main2.m

% Uncomment any of the provided sample experiments, or add your own.


% cleanup
close('all');
clear all;

global_options = struct;
global_options.seed = 13;
global_options.generator = 'twister';
global_options.output_root_path = 'output/';
global_options.generate_plots = true;

rng(global_options.seed, global_options.generator);


local_seed = 1;
experiments = {};


%%% [BEGIN] Robot: two_obstacle
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'robot', 'dataset_opts', struct('exp_list', "datasets/robot_recordings/two_obstacle/"), ...
%     'enable_regularization', false, ...
%     'deg_f', 5, 'deg_V', 2, 'deg_B', 4, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 100, 'PEN_UP', 0.0, 'UM_MAX_ITER', 250, 'PRECISION_2', 1e-9), ...
%     'yz', false);
% experiments{end}.pre = {};
% 
% experiments{end}.pre{end+1} = experiments{end}.options;
% experiments{end}.pre{end}.unmatched.restrict_to_convex = 0;
% experiments{end}.pre{end}.deg_f = 1;
% experiments{end}.pre{end}.enable_barrier = false;
% experiments{end}.pre{end}.unmatched.keep_fc = -1;
%%% [END] Robot: two_obstacle


%%% [BEGIN] Robot: box
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-4, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'robot', 'dataset_opts', struct('exp_list', "datasets/robot_recordings/box/"), ...
%     'enable_regularization', false, ...
%     'deg_f', 5, 'deg_V', 2, 'deg_B', 4, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 600, 'PEN_UP', 0.0, 'UM_MAX_ITER', 250, 'PRECISION_2', 1e-9), ...
%     'yz', true);
% experiments{end}.pre = {};
%%% [END] Robot: box


%%% [BEGIN] LASA multi: [1, 3, 5, 11, 14, 15, 19, 22, 24]
%%% Angle: 1
%%% C: 3
%%% G: 5
%%% Leaf2: 11
%%% N: 14
%%% P: 15
%%% Sine: 19
%%% S: 22
%%% Worm: 24
lasa_ids = [1, 3, 5, 11, 14, 15, 19, 22, 24];
for i = 1:length(lasa_ids)
    lid = lasa_ids(i);

    experiments{end+1}.options = fvbsettings('enable_barrier', false, ...
        'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
        'dataset', 'lasa', 'dataset_opts', struct('idx', lid, 'obstacle_repr', "ellipse_axis"), ...
        'enable_regularization', false, ...
        'deg_f', 6, 'deg_V', 4, 'deg_B', 2, 'deg_B_slack', 2, ...
        'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
        'sdpoptions_penbmi', struct('PBM_MAX_ITER', 256, 'PRECISION', 1e-5));
    experiments{end}.pre = {};

    experiments{end}.pre{end+1} = experiments{end}.options;
    experiments{end}.pre{end}.unmatched.restrict_to_convex = 0;
    experiments{end}.pre{end}.deg_f = 1;
    experiments{end}.pre{end}.enable_barrier = false;
    experiments{end}.pre{end}.unmatched.keep_fc = -1;
end
%%% [END] LASA multi: [1, 3, 5, 11, 14, 15, 19, 22, 24]


%%% [BEGIN] LASA 11: Leaf2, elliptic obstacle
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'lasa', 'dataset_opts', struct('idx', 11, 'obstacle_repr', "ellipse_axis"), ...
%     'enable_regularization', false, ...
%     'deg_f', 5, 'deg_V', 4, 'deg_B', 4, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 50, 'PEN_UP', 0.0, 'UM_MAX_ITER', 250));
% experiments{end}.pre = {};
%%% [END] LASA 11: Leaf2


%%% [BEGIN] LASA 15: P, elliptic obstacle
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'lasa', 'dataset_opts', struct('idx', 15, 'obstacle_repr', "ellipse_axis"), ...
%     'enable_regularization', false, ...
%     'deg_f', 4, 'deg_V', 2, 'deg_B', 3, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 50, 'PEN_UP', 0.0, 'UM_MAX_ITER', 250));
% experiments{end}.pre = {};
% 
% experiments{end}.pre{end+1} = experiments{end}.options;
% experiments{end}.pre{end}.unmatched.restrict_to_convex = 0;
% experiments{end}.pre{end}.deg_f = 1;
% experiments{end}.pre{end}.enable_barrier = false;
% experiments{end}.pre{end}.unmatched.keep_fc = -1;
%%% [END] LASA 15: P


%%% [BEGIN] LASA 22: S, elliptic obstacle
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'lasa', 'dataset_opts', struct('idx', 22, 'obstacle_repr', "ellipse_axis"), ...
%     'enable_regularization', false, ...
%     'deg_f', 5, 'deg_V', 2, 'deg_B', 3, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 100, 'PEN_UP', 0.0, 'UM_MAX_ITER', 250));
% experiments{end}.pre = {};
% 
% experiments{end}.pre{end+1} = experiments{end}.options;
% experiments{end}.pre{end}.unmatched.restrict_to_convex = 0;
% experiments{end}.pre{end}.deg_f = 1;
% experiments{end}.pre{end}.enable_barrier = false;
% experiments{end}.pre{end}.unmatched.keep_fc = -1;
%%% [END] LASA 22: S


%%% [BEGIN] LASA 24: Worm, elliptic obstacle
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'lasa', 'dataset_opts', struct('idx', 24, 'obstacle_repr', "ellipse_axis"), ...
%     'enable_regularization', false, ...
%     'deg_f', 4, 'deg_V', 2, 'deg_B', 3, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 50, 'PEN_UP', 0.0));
% experiments{end}.pre = {};
% 
% experiments{end}.pre{end+1} = experiments{end}.options;
% experiments{end}.pre{end}.unmatched.restrict_to_convex = 0;
% experiments{end}.pre{end}.deg_f = 1;
% experiments{end}.pre{end}.enable_barrier = false;
% experiments{end}.pre{end}.unmatched.keep_fc = -1;
% 
% experiments{end}.pre{end+1} = experiments{end}.options;
% experiments{end}.pre{end}.enable_barrier = false;
% experiments{end}.pre{end}.sdpoptions_penbmi.PBM_MAX_ITER = 50;
% experiments{end}.pre{end}.unmatched.keep_fc = -1;
% experiments{end}.pre{end}.unmatched.keep_Vc = -1;
%%% [END] LASA 24: Worm


%%% [BEGIN] LASA 19: Sine, u-shaped obstacle
% experiments{end+1}.options = fvbsettings('enable_barrier', true, ...
%     'epsilon', 1e-3, 'init_Bc_var', false, 'constraint_version', 3, ...
%     'dataset', 'lasa', 'dataset_opts', struct('idx', 19, 'obstacle_repr', "poly"), ...
%     'enable_regularization', false, ...
%     'deg_f', 5, 'deg_V', 2, 'deg_B', 4, 'deg_B_slack', 2, ...
%     'enable_extra_constraint', true, 'regularization_factor', 0.01, 'seed', local_seed, ...
%     'sdpoptions_penbmi', struct('PBM_MAX_ITER', 100, 'PEN_UP', 0.0, 'UM_MAX_ITER', 250));
% experiments{end}.pre = {};
%%% [END] LASA 19: Sine


for curr_exp_idx = 1:length(experiments)
    rng_savepoint = rng;
    fprintf("Experiment %u of %u:\n", curr_exp_idx, length(experiments));
    try
        options = experiments{curr_exp_idx}.options;
        
        [result, options] = run_experiment(global_options, options, experiments{curr_exp_idx}.pre);

        % unscaled poly str to file
        M = length(result.f_fh_str_arr);
        poly_str_filename = strcat(global_options.output_root_path, result.timestamp, '_generated_DS_unscaled.txt');
        [poly_str_fid, msg] = fopen(poly_str_filename, 'at');
        assert(poly_str_fid >= 3, msg)
        for m = 1:M
            poly_str = xistr2xystr(result.f_fh_str_arr{m}, "xi1", "x");
            poly_str = xistr2xystr(poly_str, "xi2", "y");
            if m < M
                fprintf(poly_str_fid, '%s\n', poly_str);
            else
                fprintf(poly_str_fid, '%s', poly_str);
            end
        end
        fclose(poly_str_fid);
        
        % scaled poly str to file
        if strcmp(options.dataset, 'robot')
            M = length(result.f_fh_str_arr_scaled);
            poly_str_filename = strcat(global_options.output_root_path, result.timestamp, '_generated_DS.txt');
            [poly_str_fid, msg] = fopen(poly_str_filename, 'at');
            assert(poly_str_fid >= 3, msg)
            for m = 1:M
                poly_str = xistr2xystr(result.f_fh_str_arr_scaled{m}, "xi1", "x");
                poly_str = xistr2xystr(poly_str, "xi2", "y");
                if m < M
                    fprintf(poly_str_fid, '%s\n', poly_str);
                else
                    fprintf(poly_str_fid, '%s', poly_str);
                end
            end
            fclose(poly_str_fid);
        end

        % unscaled V str to file
        M = length(result.V_fh_str_arr);
        poly_str_filename = strcat(global_options.output_root_path, result.timestamp, '_V_unscaled.txt');
        [poly_str_fid, msg] = fopen(poly_str_filename, 'at');
        assert(poly_str_fid >= 3, msg)
        for m = 1:M
            poly_str = xistr2xystr(result.V_fh_str_arr{m}, "xi1", "x");
            poly_str = xistr2xystr(poly_str, "xi2", "y");
            if m < M
                fprintf(poly_str_fid, '%s\n', poly_str);
            else
                fprintf(poly_str_fid, '%s', poly_str);
            end
        end
        fclose(poly_str_fid);
        
        % scaled V str to file
        if strcmp(options.dataset, 'robot')
            M = length(result.V_fh_str_arr_scaled);
            poly_str_filename = strcat(global_options.output_root_path, result.timestamp, '_V.txt');
            [poly_str_fid, msg] = fopen(poly_str_filename, 'at');
            assert(poly_str_fid >= 3, msg)
            for m = 1:M
                poly_str = xistr2xystr(result.V_fh_str_arr_scaled{m}, "xi1", "x");
                poly_str = xistr2xystr(poly_str, "xi2", "y");
                if m < M
                    fprintf(poly_str_fid, '%s\n', poly_str);
                else
                    fprintf(poly_str_fid, '%s', poly_str);
                end
            end
            fclose(poly_str_fid);
        end

        % unscaled B str to file
        M = length(result.B_fh_str_arr);
        poly_str_filename = strcat(global_options.output_root_path, result.timestamp, '_B_unscaled.txt');
        [poly_str_fid, msg] = fopen(poly_str_filename, 'at');
        assert(poly_str_fid >= 3, msg)
        for m = 1:M
            poly_str = xistr2xystr(result.B_fh_str_arr{m}, "xi1", "x");
            poly_str = xistr2xystr(poly_str, "xi2", "y");
            if m < M
                fprintf(poly_str_fid, '%s\n', poly_str);
            else
                fprintf(poly_str_fid, '%s', poly_str);
            end
        end
        fclose(poly_str_fid);
        
        % scaled B str to file
        if strcmp(options.dataset, 'robot')
            M = length(result.B_fh_str_arr_scaled);
            poly_str_filename = strcat(global_options.output_root_path, result.timestamp, '_B.txt');
            [poly_str_fid, msg] = fopen(poly_str_filename, 'at');
            assert(poly_str_fid >= 3, msg)
            for m = 1:M
                poly_str = xistr2xystr(result.B_fh_str_arr_scaled{m}, "xi1", "x");
                poly_str = xistr2xystr(poly_str, "xi2", "y");
                if m < M
                    fprintf(poly_str_fid, '%s\n', poly_str);
                else
                    fprintf(poly_str_fid, '%s', poly_str);
                end
            end
            fclose(poly_str_fid);
        end
    catch ME
        fprintf(2, '[ERROR] %s (More info: %s)\n', ME.identifier, ME.message);
        fprintf(2, '%s\n', getReport(ME, 'extended'));
    
        diary off;
    
        pause(2);
    end
    rng(rng_savepoint);
end
[END] main2.m


[BEGIN] run_experiment.m

function [result, options] = run_experiment(global_options, options, pre)

yalmip('clear');

global_options = add_default_option(global_options, 'image_resolution', 600);
output_root_path = global_options.output_root_path;

timestamp = string(datetime('now', 'format', 'yyyy-MM-dd_HHmmss'));
diary_filename = strcat(output_root_path, timestamp, '_log.txt');
diary(diary_filename);

rng(options.seed, global_options.generator);

result = [];


%% load reference trajectories
switch options.dataset
    case 'lasa'
        lasa_idx = options.dataset_opts.idx;
        rd = RefData;
        rd.loadLasa(lasa_idx);
        
        initial_set_center = rd.xi0_mean;
        initial_set_radius = 0.1;

        switch lasa_idx
            case 1
                unsafe_set_center = [-0.51; 0.3];
                unsafe_set_radius = 0.15;
            case 3
                unsafe_set_center = [-0.31; 0.33];
                unsafe_set_radius = 0.15;
                ellipse_center_position = [-0.1234, 0.3208];
                ellipse_axes_length = [0.1746*2*2, 0.0824*2];
                ellipse_orientation = -5 / 180 * pi;
            case 4
                unsafe_set_center = [-0.81; -0.58];
                unsafe_set_radius = 0.125;
            case 5
                unsafe_set_center = [-0.2; 0.25];
                unsafe_set_radius = 0.1;
            case 11
                ellipse_center_position = [-0.3925, 0.0253];
                ellipse_axes_length = [0.3593*2, 0.1441*2];
                ellipse_orientation = 78 / 180 * pi;
            case 14
                unsafe_set_center = [-0.2; -0.09];
                unsafe_set_radius = 0.075;
            case 15
                unsafe_set_center = [-0.21; 0.37];
                unsafe_set_radius = 0.175;
                ellipse_center_position = [-0.27, -0.35];
                ellipse_axes_length = [0.5181*2, 0.1203*2];
                ellipse_orientation = 99 / 180 * pi;
                initial_set_radius = 0.15;
            case 19
                unsafe_set_center = [-0.43; 0.14];
                unsafe_set_radius = 0.1;
                initial_set_radius = 0.07;
            case 22
                ellipse_center_position = [0.4054, 0.5528];
                ellipse_axes_length = [0.1978*2*1.5, 0.0877*2];
                ellipse_orientation = -5 / 180 * pi;
            case 24
                unsafe_set_center = [-0.5; 0.07];
                unsafe_set_radius = 0.1;
                ellipse_center_position = [-0.495, 0];
                ellipse_axes_length = [0.07*2, 0.2*2];
                ellipse_orientation = 5 / 180 * pi;
            otherwise
                warning('Unknown unsafe set parameters for LASA %s.', num2str(lasa_idx));
                unsafe_set_center = [1; 1];
                unsafe_set_radius = 1e-4;
                ellipse_center_position = [1,1];
                ellipse_axes_length = [0.01, 0.01];
                ellipse_orientation = 0;
        end
    case 'robot'
        exp_list = options.dataset_opts.exp_list;
        exp_list_cellarr = fileread(exp_list + "reference_trajectories.txt");
        exp_list_cellarr = regexp(exp_list_cellarr, '\r\n|\r|\n', 'split');

        [Data, Target, indivTrajStartIndices, timestamps] = recorded_trajectories_to_refdata(exp_list_cellarr, 100, "record", options.unmatched.yz);
        M = 2;
        shift = Target;
        Data(1:M, :) = Data(1:M, :) - shift;
        Target = [0; 0];
        rd = RefData;
        rd.directInit(Data, Target, indivTrajStartIndices, timestamps, true);

        initial_set_center = rd.xi0_mean;
        initial_set_radius = 0.05;
end


x_min = min(rd.Data(1, :));
x_max = max(rd.Data(1, :));
x_range = x_max - x_min;
y_min = min(rd.Data(2, :));
y_max = max(rd.Data(2, :));
y_range = y_max - y_min;
xy_range = max(x_range, y_range);
x_limit_fact = 1.0;
y_limit_fact = 1.0;
x_lowerlim = x_min - xy_range * x_limit_fact;
x_upperlim = x_max + xy_range * x_limit_fact;
y_lowerlim = y_min - xy_range * y_limit_fact;
y_upperlim = y_max + xy_range * y_limit_fact;
limits = [x_lowerlim, x_upperlim, y_lowerlim, y_upperlim];


%% compute DS
xi = sdpvar(rd.M, 1);

% initial/safe set
r1 = initial_set_radius;
r21 = r1 * r1;
center1 = initial_set_center;
initial_set = {};
initial_set{1} = r21 - sum((xi-center1).^2, 1);

% unsafe set
unsafe_set = {};
if options.enable_barrier
    switch options.dataset
        case 'lasa'
            switch options.dataset_opts.obstacle_repr
                case "circle"
                    r = unsafe_set_radius;
                    r2 = r * r;
                    center = unsafe_set_center;
                    unsafe_set{1} = r2 - sum((xi-center).^2, 1);
                case "ellipse_eq"
                    unsafe_set{1} = 1 - (xi-C)' * A * (xi-C);
                case "ellipse_axis"
                    ell = ellipse(ellipse_center_position, ellipse_axes_length, ellipse_orientation);
                    unsafe_set{1} = ell(xi);
                case "poly"
                    [unsafe_set_coefs, unsafe_set_monomials] = file2poly("datasets/lasa_sine_ushape_unsafe_set_poly.json", xi);  % TODO: pass via option
                    unsafe_set{1} = dot(unsafe_set_coefs, unsafe_set_monomials);
            end
        case 'robot'
            [unsafe_set_coefs, unsafe_set_monomials] = file2poly(options.dataset_opts.exp_list + "unsafe_set_poly.json", xi);
            unsafe_set{1} = dot(unsafe_set_coefs, unsafe_set_monomials);
    end
end

% constrain obstacle definition to workspace
% workspace = [[x_min-0.3; y_min-0.3], [x_max+0.3; y_max+0.3]];
% unsafe_set{2} = xi(1) - workspace(1,1);
% unsafe_set{3} = workspace(1,2) - xi(1);
% unsafe_set{4} = xi(2) - workspace(2,1);
% unsafe_set{5} = workspace(2,2) - xi(2);


restrict_to_convex = 1;


history = {};

for pre_idx = 1:length(pre)
    pre_options = pre{pre_idx};
    pre_restrict_to_convex = restrict_to_convex;
    if isfield(pre_options.unmatched, 'restrict_to_convex') && pre_options.unmatched.restrict_to_convex == 0
        pre_restrict_to_convex = 0;
    end
    [~, ~, ~, ~, ~, pre_debug_output, pre_fc, pre_Vc, pre_Bc] = fvb(rd, pre_restrict_to_convex, xi, initial_set, unsafe_set, pre_options);
    history{end+1} = struct('pre_debug_output', pre_debug_output, 'pre_fc', pre_fc, 'pre_Vc', pre_Vc, 'pre_Bc', pre_Bc);
    if pre_idx < length(pre)
        if isfield(pre_options.unmatched, 'keep_fc') && pre_options.unmatched.keep_fc ~= 0
            pre{pre_idx+1}.unmatched.fc_init = history{end+1+pre_options.unmatched.keep_fc}.pre_fc;
            pre{pre_idx+1}.unmatched.fc_init_monomials = history{end+1+pre_options.unmatched.keep_fc}.pre_debug_output.f_monomials;
            pre{pre_idx+1}.unmatched.fc_init_sdpvar = xi;
        end
        if isfield(pre_options.unmatched, 'keep_Vc') && pre_options.unmatched.keep_Vc ~= 0
            pre{pre_idx+1}.unmatched.Vc_init = history{end+1+pre_options.unmatched.keep_Vc}.pre_Vc;
            pre{pre_idx+1}.unmatched.Vc_init_monomials = history{end+1+pre_options.unmatched.keep_Vc}.pre_debug_output.V_monomials;
            pre{pre_idx+1}.unmatched.Vc_init_sdpvar = xi;
        end
        if isfield(pre_options.unmatched, 'keep_Bc') && pre_options.unmatched.keep_Bc ~= 0
            pre{pre_idx+1}.unmatched.Bc_init = history{end+1+pre_options.unmatched.keep_Bc}.pre_Bc;
            pre{pre_idx+1}.unmatched.Bc_init_monomials = history{end+1+pre_options.unmatched.keep_Bc}.pre_debug_output.B_monomials;
            pre{pre_idx+1}.unmatched.Bc_init_sdpvar = xi;
        end
    else
        if isfield(pre_options.unmatched, 'keep_fc') && pre_options.unmatched.keep_fc ~= 0
            options.unmatched.fc_init = history{end+1+pre_options.unmatched.keep_fc}.pre_fc;
            options.unmatched.fc_init_monomials = history{end+1+pre_options.unmatched.keep_fc}.pre_debug_output.f_monomials;
            options.unmatched.fc_init_sdpvar = xi;
        end
        if isfield(pre_options.unmatched, 'keep_Vc') && pre_options.unmatched.keep_Vc ~= 0
            options.unmatched.Vc_init = history{end+1+pre_options.unmatched.keep_Vc}.pre_Vc;
            options.unmatched.Vc_init_monomials = history{end+1+pre_options.unmatched.keep_Vc}.pre_debug_output.V_monomials;
            options.unmatched.Vc_init_sdpvar = xi;
        end
        if isfield(pre_options.unmatched, 'keep_Bc') && pre_options.unmatched.keep_Bc ~= 0
            options.unmatched.Bc_init = history{end+1+pre_options.unmatched.keep_Bc}.pre_Bc;
            options.unmatched.Bc_init_monomials = history{end+1+pre_options.unmatched.keep_Bc}.pre_debug_output.B_monomials;
            options.unmatched.Bc_init_sdpvar = xi;
        end
    end
    
end

[fhat, V, dVdx, B, dBdx, debug_output, fc, Vc, Bc] = fvb(rd, restrict_to_convex, xi, initial_set, unsafe_set, options);

f = fhat;

result.id = timestamp;
result.mse = debug_output.mse;
result.actual_mse = result.mse * 2;
result.min_q_eigvals = debug_output.min_q_eigvals;
result.primal_residuals = debug_output.primal_residuals;
result.relative_factors = debug_output.relative_factors;
result.comp_time = debug_output.sol.solvertime;
result.fc = fc;
result.Vc = Vc;
result.Bc = Bc;

result.timestamp = timestamp;


[~, f_fh_str_arr] = mvfun2str(f);
result.f_fh_str_arr = f_fh_str_arr;
if strcmp(options.dataset, 'robot')
    f_scaled_back = @(xi) f((xi - shift) ./ rd.state_maxnorm) .* rd.vel_maxnorm;
    [~, f_fh_str_arr_scaled] = mvfun2str(f_scaled_back);
    result.f_fh_str_arr_scaled = f_fh_str_arr_scaled;
end

[~, V_fh_str_arr] = mvfun2str(V);
result.V_fh_str_arr = V_fh_str_arr;
if strcmp(options.dataset, 'robot')
    V_scaled_back = @(xi) V((xi - shift) ./ rd.state_maxnorm);
    [~, V_fh_str_arr_scaled] = mvfun2str(V_scaled_back);
    result.V_fh_str_arr_scaled = V_fh_str_arr_scaled;
end

[~, B_fh_str_arr] = mvfun2str(B);
result.B_fh_str_arr = B_fh_str_arr;
if strcmp(options.dataset, 'robot')
    B_scaled_back = @(xi) B((xi - shift) ./ rd.state_maxnorm);
    [~, B_fh_str_arr_scaled] = mvfun2str(B_scaled_back);
    result.B_fh_str_arr_scaled = B_fh_str_arr_scaled;
end


% result_json = struct;
result_json = result;
result_json_filename = strcat(output_root_path, timestamp, '_result.json');
result_json_content = jsonencode(result_json);
result_json_fid = fopen(result_json_filename, 'w');
fprintf(result_json_fid , '%s', result_json_content);
fclose(result_json_fid);


options_log_filename = strcat(output_root_path, timestamp, '_options.json');
options_copy = options;
if isfield(options_copy, 'unmatched')
    options_copy = rmfield(options_copy, 'unmatched'); % FIXME
end
options_log_content = jsonencode(options_copy);
options_log_fid = fopen(options_log_filename, 'w');
fprintf(options_log_fid , '%s', options_log_content);
fclose(options_log_fid);


if global_options.generate_plots
    %% plotting
    % plot setup
    plot_dim1 = 1;
    plot_dim2 = 2;
    
    fig = setup_figure();
    
    xlabel(strcat('\xi_', int2str(plot_dim1)));
    ylabel(strcat('\xi_', int2str(plot_dim2)));
    
    % reference trajectories and equilibrium
    plot_objs = rd.plotLines(plot_dim1, plot_dim2);
    
    % axis limits (depending on ref data)
    xlim([limits(1), limits(2)]);
    ylim([limits(3), limits(4)]);
    axis_limits = axis;
    
    % legend config
    leg = findobj(gcf, 'Type', 'Legend');
    leg.ItemTokenSize(1) = 15;
    
    
    % plot DS
    streamlines_plt = plot_streamlines_for_f(f, axis_limits);
    set(streamlines_plt(1), 'displayname', '$f(\xi)$');
    set(streamlines_plt(2:end), 'handlevisibility', 'off');


    resolution = 0.01;
    [X, Y] = meshgrid(axis_limits(1)-resolution:resolution:axis_limits(2)+resolution, axis_limits(3)-resolution:resolution:axis_limits(4)+resolution);
    XY = [X(:)'; Y(:)'];
    
    % plot Lyapunov function
    Vfun_eval = reshape(V(XY), size(X));
    [C, plt_V] = contourf(X, Y, Vfun_eval, 'linecolor', 'white', 'linewidth', 0.5, 'displayname', '$V(\xi)$');
    cmap = crameri('lajolla');
    cmap = cmap(1:160, :);
    cmap = cmap(round(linspace(1, 160, 10)), :);
    colormap(cmap);
    uistack(plt_V, 'bottom');
    
    
    % plot Barrier zero-level curve
    if options.enable_barrier
        Bfun_eval = reshape(B(XY), size(X));
        contour(X, Y, Bfun_eval, [0, 0], 'linewidth', 1, 'color', '#7D0675', 'displayname', '$B(\xi)=0$');
        hold on;
        
        % plot initial set
        for p = 1:length(initial_set)
            fgptilde = sdpvar2fun(initial_set{p}, xi);
            Fgptilde = reshape(fgptilde(XY), size(X));
            [cctilde, hhtilde] = contourf(X, Y, Fgptilde, [0, 0], 'linewidth', 1, 'color', 'cyan', 'facecolor', 'cyan', 'facealpha', 0.35, 'displayname', strcat('$\mathcal{D}_{0;', int2str(p), '}$'));
            hold on;
        end
    
        % plot unsafe set
        for m = 1:length(unsafe_set)
            fgm = sdpvar2fun(unsafe_set{m}, xi);
            Fgm = reshape(fgm(XY), size(X));
            [cc, hh] = contourf(X, Y, Fgm, [0, 0], 'linewidth', 1, 'color', 'black', 'facecolor', 'black', 'facealpha', 0.35, 'displayname', strcat('$\mathcal{D}_{u;', int2str(m), '}$'));
            hold on;
        end
    end
    
    
    % sample trajectories from estimated DS
    initial_set_center_est = rd.xi0_mean;
    % initial_set_center_est = rd.Data(1:rd.M, rd.indivTrajStartIndices(1:end-1));

    rd_est = RefData;
    [Data_est, Target_est, indivTrajStartIndices_est, Timestamps_est] = generateRefData(f, initial_set_center_est);
    rd_est.directInit(Data_est, Target_est, indivTrajStartIndices_est, Timestamps_est, false);
    plt_sampled_traj = rd_est.plotLines(plot_dim1, plot_dim2, {'markeredgecolor', 'none', 'markerfacecolor', 'none', 'handlevisibility', 'off'}, {'color', '#ff00ff'});
    
    
    cbar = colorbar('ticks', plt_V.LevelList, 'ticklabels', plt_V.LevelList);
    yt = get(cbar, 'ytick');
    set(cbar, 'yticklabel', sprintf('%.2g\n', yt));
    set(cbar, 'ticklabelinterpreter', 'latex');

    % save figure
    filename = strcat(output_root_path, timestamp, '.png'); % TODO: change to '.pdf'
    exportgraphics(fig, filename, 'contenttype', 'image', 'resolution', global_options.image_resolution); % TODO: change to 'vector'
    
    
    %% plot V
    filename = strcat(output_root_path, timestamp, '_V.png'); % TODO: change to '.pdf'
    figV = plot_V(plot_dim1, plot_dim2, X, Y, Vfun_eval, axis_limits, streamlines_plt, filename, global_options.image_resolution);
    close(figV);

    
    %% plot B
    if options.enable_barrier
        filename = strcat(output_root_path, timestamp, '_B.png'); % TODO: change to '.pdf'
        figB = plot_B(plot_dim1, plot_dim2, X, Y, Bfun_eval, axis_limits, streamlines_plt, filename, global_options.image_resolution);
        close(figB);
    end
    
    
    %%
    close(fig);
end


%%
diary off;

sources_filename = strcat(output_root_path, timestamp, '_sources.txt');
[sources_logfile_fid, msg] = fopen(sources_filename, 'at');
assert(sources_logfile_fid >= 3, msg)
append_to_logfile(sources_logfile_fid, {'main2.m', 'run_experiment.m', 'fvb.m'});
fclose(sources_logfile_fid);


end
[END] run_experiment.m


[BEGIN] fvb.m

function [f_fh, V_fh, dVdx_fh, B_fh, dBdx_fh, debug_output, fc, Vc, Bc] = fvb(rd, restrict_to_convex, xi, initial_set, unsafe_set, options)
% rd: RefData object encapsulating the reference trajectories
% restrict_to_convex:
%   0: solve easier convex problem with fixed Lyapunov function
%   1: solve full problem but init with solution of easier problem
% xi: sdpvar corresponding to state space
% initial_set: cell array of sdpvar expressions of polynomials (which are to be taken as >= 0)
%   that define a semi-algebraic set representation of the initial set
% unsafe_set: cell array of sdpvar expressions of polynomials (which are to be taken as >= 0)
%   that define a semi-algebraic set representation of the unsafe set
% options: see fvbsettings.m
%
% assumption: attractor is at the origin

epsilon = options.epsilon;

debug_output = struct;


% Reference trajectories
M = rd.M; % # states
T = rd.T; % time/sample index (all demonstrations concatenated)


%% Define variables
deg_f = options.deg_f;
f = [];
fc_var = [];
for m = 1:M
    [f_tmp, fc_var_tmp, f_monomials] = polynomial(xi, deg_f, 1);
    f = [f; f_tmp];
    fc_var = [fc_var; fc_var_tmp];
end
debug_output.f_monomials = f_monomials;

% Lyapunov function
if restrict_to_convex == 0
    V = xi' * xi;
    [Vc_var, V_monomials] = coefficients(V, xi);
elseif restrict_to_convex == 1
    deg_V = options.deg_V;
    [V, Vc_var, V_monomials] = polynomial(xi, deg_V, 1);
end
debug_output.V_monomials = V_monomials;
dVdx = jacobian(V, xi)';

% Barrier certificate
deg_B = options.deg_B;
[B, Bc_var, B_monomials] = polynomial(xi, deg_B);
debug_output.B_monomials = B_monomials;
dBdx = jacobian(B, xi)';


% init sdpvars from options struct
if isfield(options, 'unmatched')
    if isfield(options.unmatched, 'fc_init')
        assert(isfield(options.unmatched, 'fc_init_monomials'), 'options.unmatched.fc_init_monomials is required when options.unmatched.fc_init is set');
        assert(isfield(options.unmatched, 'fc_init_sdpvar'), 'options.unmatched.fc_init_sdpvar is required when options.unmatched.fc_init is set');

        fc_init_tmp = zeros(length(f_monomials), M);
        % Assign the computed coefficient values to the matching coefficients of the higher-deg polynomial
        fc_init_reshaped = reshape(options.unmatched.fc_init, length(options.unmatched.fc_init)/M, M);
        fc_init_monomials_replaced = replace(options.unmatched.fc_init_monomials, options.unmatched.fc_init_sdpvar, xi);
        [idx_from, idx_to] = match_monomials(sdisplay(fc_init_monomials_replaced), sdisplay(f_monomials));
        for m = 1:M
            fc_init_tmp(idx_to, m) = fc_init_reshaped(idx_from, m);
        end
        assign(fc_var, fc_init_tmp(:));
    end
    if isfield(options.unmatched, 'Vc_init')
        assert(isfield(options.unmatched, 'Vc_init_monomials'), 'options.unmatched.Vc_init_monomials is required when options.unmatched.Vc_init is set');
        assert(isfield(options.unmatched, 'Vc_init_sdpvar'), 'options.unmatched.Vc_init_sdpvar is required when options.unmatched.Vc_init is set');

        Vc_init_tmp = zeros(size(Vc_var));
        % Assign the computed coefficient values to the matching coefficients of the higher-deg polynomial
        Vc_init_monomials_replaced = replace(options.unmatched.Vc_init_monomials, options.unmatched.Vc_init_sdpvar, xi);
        [idx_from, idx_to] = match_monomials(sdisplay(Vc_init_monomials_replaced), sdisplay(V_monomials));
        Vc_init_tmp(idx_to) = options.unmatched.Vc_init(idx_from);
        assign(Vc_var, Vc_init_tmp);
    end
    if isfield(options.unmatched, 'Bc_init')
        assert(isfield(options.unmatched, 'Bc_init_monomials'), 'options.unmatched.Bc_init_monomials is required when options.unmatched.Bc_init is set');
        assert(isfield(options.unmatched, 'Bc_init_sdpvar'), 'options.unmatched.Bc_init_sdpvar is required when options.unmatched.Bc_init is set');

        Bc_init_tmp = zeros(size(Bc_var));
        % Assign the computed coefficient values to the matching coefficients of the higher-deg polynomial
        Bc_init_monomials_replaced = replace(options.unmatched.Bc_init_monomials, options.unmatched.Bc_init_sdpvar, xi);
        [idx_from, idx_to] = match_monomials(sdisplay(Bc_init_monomials_replaced), sdisplay(B_monomials));
        Bc_init_tmp(idx_to) = options.unmatched.Bc_init(idx_from);
        assign(Bc_var, Bc_init_tmp);
    end
end


%% Objective
xi_dot = sdpvar(M, T, 'full');
for t = 1:T
    xi_dot(:, t) = replace(f, xi, rd.Data(1:M, t));
end
xi_dot_error = xi_dot - rd.Data(M+1:end, :);

mse = sum(sum(xi_dot_error.^2)) / (2 * T);
Objective = mse;


%% Constraints
Constraints = [];
epxi = epsilon * sum(xi.^2, 1);

% Stability
if restrict_to_convex == 1
    Constraints = [Constraints, (sos(V-epxi)):'V > 0'];
end
Vdot = sum(dVdx.*f, 1);
% Lie derivative
Constraints = [Constraints, (sos(-Vdot-epxi)):'-Vdot < 0'];

% Barrier
if options.enable_barrier
    deg_B_slack = options.deg_B_slack;

    % initial set
    tau_arr = {};
    tauc_arr = {};
    tau_monomials_arr = {};
    sos_safe = -B;
    for p = 1:length(initial_set)
        [tau_arr{p}, tauc_arr{p}, tau_monomials_arr{p}] = polynomial(xi, deg_B_slack);
        Constraints = [Constraints, sos(tau_arr{p})];
        sos_safe = sos_safe - tau_arr{p} * initial_set{p};
    end
    Constraints = [Constraints, sos(sos_safe)];
    debug_output.tau_arr = tau_arr;
    debug_output.tauc_arr = tauc_arr;
    debug_output.tau_monomials_arr = tau_monomials_arr;

    % unsafe set
    sig_arr = {};
    sigc_arr = {};
    sig_monomials_arr = {};
    sos_unsafe = B - epsilon;
    for m = 1:length(unsafe_set)
        [sig_arr{m}, sigc_arr{m}, sig_monomials_arr{m}] = polynomial(xi, deg_B_slack);
        Constraints = [Constraints, sos(sig_arr{m})];
        sos_unsafe = sos_unsafe - sig_arr{m} * unsafe_set{m};
    end
    Constraints = [Constraints, sos(sos_unsafe)];
    debug_output.sig_arr = sig_arr;
    debug_output.sigc_arr = sigc_arr;
    debug_output.sig_monomials_arr = sig_monomials_arr;

    % Lie derivative
    Bdot = sum(dBdx.*f, 1);
    switch options.constraint_version
        case 1
            Constraints = [Constraints, sos(-Bdot-epxi)];
        case 2
            [slackvar, slackvarc, slackvar_monomials] = polynomial(xi, deg_B_slack);
            Constraints = [Constraints, sos(slackvar)];
            Constraints = [Constraints, sos(-Bdot-epxi-slackvar*(epsilon - B))];
            debug_output.slackvar = slackvar;
            debug_output.slackvarc = slackvarc;
            debug_output.slackvar_monomials = slackvar_monomials;
        case 3
            [slackvar, slackvarc, slackvar_monomials] = polynomial(xi, deg_B_slack);
            Constraints = [Constraints, sos(slackvar)];
            Constraints = [Constraints, sos(-Bdot-epxi-slackvar*(epsilon - B.^2))]; % restrict to B^{-1}(0)
            debug_output.slackvar = slackvar;
            debug_output.slackvarc = slackvarc;
            debug_output.slackvar_monomials = slackvar_monomials;
    end

    if options.enable_extra_constraint
        B_tmp3 = 0;
        for t = 1:T
            B_tmp3 = B_tmp3 + max([0, replace(B, xi, rd.Data(1:M, t))]);
        end
        Constraints = [Constraints, B_tmp3 <= 0]; % TODO: maybe use -epsilon on right side
    end
end

%% Optimize
params = [];
params = [params; fc_var(:)];
if restrict_to_convex == 1
    params = [params; Vc_var(:)];
end
if options.enable_barrier
    params = [params; Bc_var];
    for p = 1:length(initial_set)
        params = [params; tauc_arr{p}];
    end
    for m = 1:length(unsafe_set)
        params = [params; sigc_arr{m}];
    end
    if options.constraint_version == 2 || options.constraint_version == 3
        params = [params; slackvarc];
    end
end


if options.enable_regularization
    Objective = Objective + options.regularization_factor * norm(fc_var(:), 'fro')^2;
end


tmp_sdpoptions = options.sdpoptions;
tmp_sdpoptions = namedargs2cell(tmp_sdpoptions);
tmp_sdpoptions_penbmi = options.sdpoptions_penbmi;
tmp_sdpoptions_penbmi = namedargs2cell(tmp_sdpoptions_penbmi);
for idx = 1:length(tmp_sdpoptions_penbmi)
    if mod(idx, 2) == 1
        tmp_sdpoptions_penbmi(idx) = append('penbmi.', tmp_sdpoptions_penbmi(idx));
    end
end

final_sdpoptions = [tmp_sdpoptions, tmp_sdpoptions_penbmi];


% Solver options
if restrict_to_convex == 0
    sdp_options = sdpsettings('verbose', 1);
elseif restrict_to_convex == 1
    sdp_options = sdpsettings('solver', 'penbmi', 'verbose', 1, 'debug', 1, 'showprogress', 1, 'usex0', 1, 'warmstart', 1);
    %                                                                           Default     More Info
    % sdp_options = sdpsettings(sdp_options, 'penbmi.PBM_MAX_ITER', 10000);     % 50        maximum number of iterations of the overall algorithm
    sdp_options = sdpsettings(sdp_options, 'penbmi.OUTPUT', 3);                 % 1
    % sdp_options = sdpsettings(sdp_options, 'penbmi.ALPHA', 1e-6);             % 0.01      stopping criterium for unconstrained minimization; YALMIP lower bounds it by 1e-6
    
    % sdp_options = sdpsettings(sdp_options, 'penbmi.UM_MAX_ITER', 1000);       % 100       maximum number of iterations for the unconstrained minimization
    % sdp_options = sdpsettings(sdp_options, 'penbmi.LS', 1);                   % 0
    % sdp_options = sdpsettings(sdp_options, 'penbmi.NWT_SYS_MODE', 1);         % 0
    % sdp_options = sdpsettings(sdp_options, 'penbmi.PREC_TYPE', 1);            % 0
    % sdp_options = sdpsettings(sdp_options, 'penbmi.TR_MODE', 1);              % 0
    % sdp_options = sdpsettings(sdp_options, 'penbmi.PRECISION', 1e-6);         % 1e-6      stopping criterium for the overall algorithm (likely corresponds to PBM_EPS in PENBMI doc)
    % sdp_options = sdpsettings(sdp_options, 'penbmi.P_EPS', 1e-6);             % 1e-4
    % sdp_options = sdpsettings(sdp_options, 'penbmi.P0', 0.01);                % 0.1
    % sdp_options = sdpsettings(sdp_options, 'penbmi.PEN_UP', 0.0);             % 0.5
    % if options.enable_barrier
    %     warning('Check if it makes sense to lower the initial penalty when including a Barrier function -> is the initial guess feasible?');
    % end
    % sdp_options = sdpsettings(sdp_options, 'penbmi.ALPHA_UP', 1.0);           % 1.0
    % sdp_options = sdpsettings(sdp_options, 'penbmi.PRECISION_2', 1e-2);       % 1e-6      precision of the KKT conditions

    sdp_options = sdpsettings(sdp_options, final_sdpoptions{:});
end


% Call solver
if sum(logical(is(Constraints, 'sos'))) > 0
    [sol, v, Q, res] = solvesos(Constraints, Objective, sdp_options, params);
else
    sol = optimize(Constraints, Objective, sdp_options);
    v = [];
    Q = [];
    res = [];
end
debug_output.v = v;
debug_output.Q = Q;
debug_output.res = res;

if sol.problem ~= 0
    yalmiperror(sol.problem);
end


% Optimization result
sol.info
check(Constraints)
fprintf('Total error: %2.2f\nComputation Time: %2.2f\n', value(Objective), sol.solvertime);
debug_output.sol = sol;


% Output variables
f_fh = replace(f, fc_var, value(fc_var));
f_fhm = {};
f_fh_str = '@(xi) [';
for m = 1:M
    f_fhm{m} = sdpvar2fun(f_fh(m), xi);
    f_fh_str = strcat(f_fh_str, 'f_fhm{', num2str(m), '}(xi);');
end
f_fh_str = strcat(f_fh_str, ']');
f_fh = eval(f_fh_str);

if restrict_to_convex == 1
    V_fh = replace(V, Vc_var, value(Vc_var));
    V_fh = sdpvar2fun(V_fh, xi);

    dVdx_fh = replace(dVdx, Vc_var, value(Vc_var));
    dVdx_fhm = {};
    dVdx_fh_str = '@(xi) [';
    for m = 1:M
        dVdx_fhm{m} = sdpvar2fun(dVdx_fh(m), xi);
        dVdx_fh_str = strcat(dVdx_fh_str, 'dVdx_fhm{', num2str(m), '}(xi);');
    end
    dVdx_fh_str = strcat(dVdx_fh_str, ']');
    dVdx_fh = eval(dVdx_fh_str);
else % TODO: unify with above case
    V_fh = sdpvar2fun(V, xi);

    dVdx_fhm = {};
    dVdx_fh_str = '@(xi) [';
    for m = 1:M
        dVdx_fhm{m} = sdpvar2fun(dVdx(m), xi);
        dVdx_fh_str = strcat(dVdx_fh_str, 'dVdx_fhm{', num2str(m), '}(xi);');
    end
    dVdx_fh_str = strcat(dVdx_fh_str, ']');
    dVdx_fh = eval(dVdx_fh_str);
end

B_fh = replace(B, Bc_var, value(Bc_var));
B_fh = sdpvar2fun(B_fh, xi);

dBdx_fh = replace(dBdx, Bc_var, value(Bc_var));
dBdx_fhm = {};
dBdx_fh_str = '@(xi) [';
for m = 1:M
    dBdx_fhm{m} = sdpvar2fun(dBdx_fh(m), xi);
    dBdx_fh_str = strcat(dBdx_fh_str, 'dBdx_fhm{', num2str(m), '}(xi);');
end
dBdx_fh_str = strcat(dBdx_fh_str, ']');
dBdx_fh = eval(dBdx_fh_str);

fc = value(fc_var);
Vc = value(Vc_var);
Bc = value(Bc_var);


[f_fh_str, ~] = mvfun2str(f_fh);
fprintf(f_fh_str);
fprintf(mvfun2str(V_fh));
fprintf(mvfun2str(dVdx_fh));
fprintf(mvfun2str(B_fh));
fprintf(mvfun2str(dBdx_fh));

debug_output.mse = value(mse);


% For SOS constraints: eigenvalues of Gramians -> compare with size of residual
fprintf('[DEBUG] Validation of SOS constraints:\n');
fprintf('+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n');
fprintf('| Idx| Min eigval of Q| Primal residual|  Relative fact.|\n');
fprintf('+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n');
min_q_eigvals = [];
primal_res = check(Constraints(logical(is(Constraints, 'sos'))));
relative_factors = [];
for i = 1:length(Q)
    min_eigval = min(eig(Q{i}));
    min_q_eigvals(end+1) = min_eigval;
    rel_fact = primal_res(i) / min_eigval;
    relative_factors(end+1) = rel_fact;
    fprintf('|%4.0f|%16g|%16g|%16g|  All eigvals of Q: %s\n', i, min_eigval, primal_res(i), rel_fact, mat2str(eig(Q{i})));
end
debug_output.min_q_eigvals = min_q_eigvals;
debug_output.primal_residuals = primal_res';
debug_output.relative_factors = relative_factors;
fprintf('+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n');
fprintf('[DEBUG_END]\n');

end
[END] fvb.m